// UTT
//
// Copyright (c) 2020-2022 VMware, Inc. All Rights Reserved.
//
// This product is licensed to you under the Apache 2.0 license (the "License").
// You may not use this product except in compliance with the Apache 2.0
// License.
//
// This product may include a number of subcomponents with separate copyright
// notices and license terms. Your use of these subcomponents is subject to the
// terms and conditions of the sub-component's license, as noted in the LICENSE
// file.

#pragma once
#include "commitment.hpp"
#include "UTTParams.hpp"
#include "common.hpp"
#include "util/types.hpp"
#include <memory>
#include <unordered_map>

namespace libutt::api {
class Coin;
namespace operations {
class Burn;
class Transaction;
}  // namespace operations
class Client {
  /**
   * @brief The Client object represents the client's public and private data and a group of relevant operations.
   *
   */
 public:
  /**
   * @brief Construct a new Client object using an IBE based PKI
   *
   * @param id The client id
   * @param bank_public_key The serialized bank public key
   * @param registration_public_key The serialized registration public key
   * @param client_ibe_secret_key The serialized IBE client's secret
   * @param ibe_mpk The serialized IBE MPK object
   */
  Client(const std::string& id,
         const std::string& bank_public_key,
         const std::string& registration_public_key,
         const std::string& client_ibe_secret_key,
         const std::string& ibe_mpk);
  /**
   * @brief Construct a new Client object with an RSA based PKI
   *
   * @param id The client id
   * @param bank_public_key The serialized bank public key
   * @param registration_public_key The serialized registration public key
   * @param rsa_secret_key A serialized RSA secret key (in PEM format)
   */
  Client(const std::string& id,
         const std::string& bank_public_key,
         const std::string& registration_public_key,
         const std::string& rsa_secret_key);
  Client();
  ~Client();
  Client(const Client&);
  Client& operator=(const Client&);
  Client(Client&&);
  Client& operator=(Client&&);
  /**
   * @brief Generates the input (partial) RCM (also marked as rcm1). This method is to be used in the first
   * registration step
   *
   * @return Commitment
   */
  Commitment generateInputRCM(uint64_t nonce = 0);

  /**
   * @brief The full PRF key is composed by a client secret (s1) and an unpredictable s2 (choose by the bank). This
   * method is to set the full PRF key by adding s2 to s1.
   *
   * @param s2 The registration service part of the secret PRF
   */
  void setPRFKey(const types::CurvePoint& s2);

  /**
   * @brief Get the client id
   *
   * @return const std::string&
   */
  const std::string& getPid() const;

  /**
   * @brief Get the client PRF key as a CurvePoint
   *
   * @return types::CurvePoint
   */
  types::CurvePoint getPRFSecretKey() const;
  types::CurvePoint getS1() const;
  void setS1(const types::CurvePoint& s1);
  /**
   * @brief Get the client id Hash as a CurvePoint
   *
   * @return types::CurvePoint
   */
  types::CurvePoint getPidHash() const;

  /**
   * @brief Set the the full RCM signature. The signature and s2 are created by the bank, to complete the registration
   * process, the client needs to compute the full RCM (using s2) and save the signature for future usage
   *
   * @param p The shared global UTT parameters
   * @param s2 The registration service part of the secret PRF
   * @param sig The full RCM signature (generated by the registration service)
   */
  void setRCMSig(const UTTParams& p, const types::CurvePoint& s2, const types::Signature& sig);

  /**
   * @brief Re-randomize the rcm and its signature. Notice, that in reality, the RCM is verified in the split proof, so
   * probably this method will be used for testing only
   *
   * @param p The shared global UTT parameters
   * @return std::pair<Commitment, types::Signature>
   */
  std::pair<Commitment, types::Signature> rerandomizeRcm(const UTTParams& p) const;

  /**
   * @brief Get the RCM and its corresponding signature. Notice, that in reality, the RCM is verified in the split
   * proof, so probably this method will be used for testing only
   *
   * @return std::pair<Commitment, types::Signature>
   */
  std::pair<Commitment, types::Signature> getRcm() const;

  /**
   * @brief Claims the coins owned by this client
   *
   * @tparam T one of <operations::Mint, operations::Budget, operations::Transaction>
   * @param p The shared global UTT parameters
   * @param blindedSigs The combined signature. Notice, that even if someone else has collected the signature, only the
   * client knows the coin's randomness and hence only the client can un-blind it
   * @return std::vector<libutt::api::Coin> A vector of coins (a transaction may returns multiple coins)
   */
  template <typename T>
  std::vector<libutt::api::Coin> claimCoins(const T&,
                                            const UTTParams& p,
                                            const std::vector<types::Signature>& blindedSigs) const;

  /**
   * @brief Validating objects that are relevant for this client
   *
   * @tparam T one of <Coin>
   * @return true if the the object is valid
   * @return false else
   */
  template <typename T>
  bool validate(const T&) const;

 private:
  friend class operations::Burn;
  friend class operations::Transaction;
  struct Impl;
  Impl* pImpl_;
  Commitment rcm_;
  types::Signature rcm_sig_;
  bool complete_s = false;
};
}  // namespace libutt::api
