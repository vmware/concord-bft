// UTT
//
// Copyright (c) 2020-2022 VMware, Inc. All Rights Reserved.
//
// This product is licensed to you under the Apache 2.0 license (the "License").
// You may not use this product except in compliance with the Apache 2.0
// License.
//
// This product may include a number of subcomponents with separate copyright
// notices and license terms. Your use of these subcomponents is subject to the
// terms and conditions of the sub-component's license, as noted in the LICENSE
// file.

#pragma once
#include "commitment.hpp"
#include "globalParams.hpp"
#include "common.hpp"
#include "types.hpp"
#include <memory>
#include <unordered_map>
namespace libutt {
class AddrSK;
class RandSigPK;
class RegAuthPK;
class IEncryptor;
class IDecryptor;
}  // namespace libutt
namespace libutt::api {
class Coin;
namespace operations {
class Burn;
class Transaction;
}  // namespace operations
class Client {
  /**
   * @brief The Client object represents the client's public and private date and a group of relevant operations.
   *
   */
 public:
  /**
   * @brief Construct a new Client object using an IBE based PKI
   *
   * @param id The client id
   * @param bnak_public_key The serialized bank public key
   * @param registration_public_key The serialized registration public key
   * @param client_ibe_secret_key The serialized IBE client's secret
   * @param ibe_mpk The serialized IBE MPK object
   */
  Client(const std::string& id,
         const std::string& bank_public_key,
         const std::string& registration_public_key,
         const std::string& client_ibe_secret_key,
         const std::string& ibe_mpk);
  /**
   * @brief Construct a new Client object with an RSA based PKI
   *
   * @param id The client id
   * @param bank_public_key The serialized bank public key
   * @param registration_public_key The serialized registration public key
   * @param rsa_secret_key A serialized RSA secret key (in PEM format)
   */
  Client(const std::string& id,
         const std::string& bank_public_key,
         const std::string& registration_public_key,
         const std::string& rsa_secret_key);

  /**
   * @brief Generates the input (paritial) RCM (also marked as rcm1). This method is to be used in the first
   * registration step
   *
   * @return Commitment
   */
  Commitment generateInputRCM();

  /**
   * @brief The full PRF key is composed by a client secret (s1) and an unpredictable s2 (choosed by the bank). This
   * method is to set the full PRF key by adding s2 to s1.
   *
   * @param s2 The registration service part of the secret PRF
   */
  void setPRFKey(const types::CurvePoint& s2);

  /**
   * @brief Get the client id
   *
   * @return const std::string&
   */
  const std::string& getPid() const;

  /**
   * @brief Get the client PRF key as a CurvePoint
   *
   * @return types::CurvePoint
   */
  types::CurvePoint getPRFSecretKey() const;

  /**
   * @brief Get the client id Hash as a CurvePoint
   *
   * @return types::CurvePoint
   */
  types::CurvePoint getPidHash() const;

  /**
   * @brief Set the the full RCM signature. The signature and s2 are created by the bank, to complete the registration
   * process, the client needs to compute the full RCM (using s2) and save the signature for futuer usage
   *
   * @param p The shared global UTT parametrs
   * @param s2 The registration service part of the secret PRF
   * @param sig The full RCM signature (generated by the registration service)
   */
  void setRCMSig(const GlobalParams& p, const types::CurvePoint& s2, const types::Signature& sig);

  /**
   * @brief Rerandomize the rcm and its signature. Notice, that in reality, the RCM is verified in the split proof, so
   * probably this method will be used for testing only
   *
   * @param p The shared global UTT parametrs
   * @return std::pair<Commitment, types::Signature>
   */
  std::pair<Commitment, types::Signature> rerandomizeRcm(const GlobalParams& p) const;

  /**
   * @brief Get the RCM and its corresponding signature. Notice, that in reality, the RCM is verified in the split
   * proof, so probably this method will be used for testing only
   *
   * @return std::pair<Commitment, types::Signature>
   */
  std::pair<Commitment, types::Signature> getRcm() const;

  /**
   * @brief Claims the coins owned by this client
   *
   * @tparam T one of <operations::Mint, operations::Budget, operations::Transaction>
   * @param p The shared global UTT parametrs
   * @param blindedSigs The combined signature. Notice, that even if someone else has collected the signature, only the
   * client knows the coin's randomness and hance only the client can unblind it
   * @return std::vector<libutt::api::Coin> A vector of coins (a transaction may returns multiple coins)
   */
  template <typename T>
  std::vector<libutt::api::Coin> claimCoins(const T&,
                                            const GlobalParams& p,
                                            const std::vector<types::Signature>& blindedSigs) const;

  /**
   * @brief Validating obejctes that are relevant for this client
   *
   * @tparam T one of <Coin>
   * @return true if the the object is valid
   * @return false else
   */
  template <typename T>
  bool validate(const T&) const;

 private:
  friend class operations::Burn;
  friend class operations::Transaction;
  std::unique_ptr<libutt::AddrSK> ask_;
  std::unique_ptr<libutt::RandSigPK> bpk_;
  std::unique_ptr<libutt::RegAuthPK> rpk_;
  std::shared_ptr<libutt::IDecryptor> decryptor_;
  Commitment rcm_;
  types::Signature rcm_sig_;
  bool complete_s = false;
};
}  // namespace libutt::api
