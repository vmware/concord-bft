// Concord
//
// Copyright (c) 2018 VMware, Inc. All Rights Reserved.
//
// This product is licensed to you under the Apache 2.0 license (the "License").
// You may not use this product except in compliance with the Apache 2.0
// License.
//
// This product may include a number of subcomponents with separate copyright
// notices and license terms. Your use of these subcomponents is subject to the
// terms and conditions of the subcomponent's license, as noted in the LICENSE
// file.

#pragma once

#include <string>
#include <iterator>
#include "Status.h"
#include "ICommunication.hpp"
#include "PrimitiveTypes.h"
#include "SetOfKeyValuePairs.h"

namespace SimpleKVBC {

    // forward declarations
    class ILocalKeyValueStorageReadOnlyIterator;
    class ILocalKeyValueStorageReadOnly;
    class IBlocksAppender;
    class ICommandsHandler;

    /////////////////////////////////////////////////////////////////////////////
    // Configuration
    /////////////////////////////////////////////////////////////////////////////

    struct ReplicaConfig
    {
        // F value - max number of faulty/malicious replicas. fVal >= 1
        uint16_t fVal;

        // C value. cVal >=0
        uint16_t cVal;

        // unique identifier of the replica.
        // The number of replicas in the system should be N = 3*fVal + 2*cVal + 1
        // In the current version, replicaId should be a number between 0 and  N-1
        // replicaId should also represent this replica in ICommunication.
        uint16_t replicaId;

        // path of the replica's security keys file (generated by CONCORD-ROOT/tools/GenerateConcordKeys)
        std::string pathOfKeysfile;

        // number of objects that represent clients.
        // numOfClientProxies >= 1
        uint16_t numOfClientProxies;

        // a time interval in milliseconds. represents how often the replica sends a status report to the other replicas.
        // statusReportTimerMillisec > 0
        uint16_t statusReportTimerMillisec;

        // number of consensus operations that can be executed in parallel
        // 1 <= concurrencyLevel <= 30
        uint16_t concurrencyLevel;

        // autoViewChangeEnabled=true , if the automatic view change protocol is enabled
        bool autoViewChangeEnabled;

        // a time interval in milliseconds. represents the timeout used by the  view change protocol (TODO: add more details)
        uint16_t viewChangeTimerMillisec;

        // maximum block size
        uint32_t maxBlockSize;
    };

    struct ClientConfig
    {
        // F value - max number of faulty/malicious replicas. fVal >= 1
        uint16_t fVal;

        // C value. cVal >=0
        uint16_t cVal;

        // unique identifier of the client.
        // clientId should also represent this client in ICommunication.
        // In the current version, replicaId should be a number between N and  N+numOfClientProxies-1
        // (N is the number replicas in the system. numOfClientProxies is part of the replicas' configuration)
        uint16_t clientId;

        // maximum reply size supported by this client
        uint32_t maxReplySize;
    };

    /////////////////////////////////////////////////////////////////////////////
    // Client proxy
    /////////////////////////////////////////////////////////////////////////////

    // Represents a client of the blockchain database
    class IClient
    {
    public:
        virtual Status start() = 0;
        virtual Status stop() = 0;

        virtual bool isRunning() = 0;

        virtual Status invokeCommandSynch(const Slice command, bool isReadOnly, Slice& outReply) = 0;

        virtual Status release(Slice& slice) = 0; // release memory allocated by invokeCommandSynch
    };

    // creates a new Client object
    IClient* createClient(const ClientConfig& conf, bftEngine::ICommunication* comm);

    // TODO: Implement:
    //  // deletes a Client object
    //  void release(IClient* r);

    /////////////////////////////////////////////////////////////////////////////
    // Replica
    /////////////////////////////////////////////////////////////////////////////

    // Represents a replica of the blockchain database
    class IReplica
    {
    public:
        virtual Status start() = 0;
        virtual Status stop()  = 0;

        enum class RepStatus // status of the replica
        {
            UnknownError = -1,
            Ready                = 0,
            Starting,
            Running,
            Stopping,
        };

        // returns the current status of the replica
        virtual RepStatus getReplicaStatus() const = 0;

// TODO: Implement:
//      // this callback is called by the library every time the replica status is changed
//      typedef void(*StatusNotifier)(RepStatus newStatus);
//      virtual Status setStatusNotifier(StatusNotifier statusNotifier);
//
//      // Used to update the local storage (may be needed for initializing and maintenance).
//      // Can only be used when the replica's status is Idle.
//      virtual const ILocalKeyValueStorageReadOnly& getReadOnlyStorage() = 0;
//      virtual Status addBlockToIdleReplica(const SetOfKeyValuePairs& updates) = 0; // write the updates by adding a block
    };

    // creates a new Replica object
    IReplica* createReplica(const ReplicaConfig& conf,
                              bftEngine::ICommunication* comm,
                              ICommandsHandler* _cmdHandler);

// TODO: Implement:
//  // deletes a Replica object
//  void release(IReplica* r);

    /////////////////////////////////////////////////////////////////////////////
    // Replica's commands handle
    /////////////////////////////////////////////////////////////////////////////

    class ICommandsHandler
    {
    public:

        virtual bool executeCommand(const Slice command,
            const ILocalKeyValueStorageReadOnly& roStorage,
            IBlocksAppender& blockAppender,
            const size_t maxReplySize,
            char* outReply, size_t& outReplySize) const = 0;

        virtual bool executeReadOnlyCommand(const Slice command,
            const ILocalKeyValueStorageReadOnly& roStorage,
            const size_t maxReplySize,
            char* outReply, size_t& outReplySize) const = 0;
    };

    // Blocks appender
    class IBlocksAppender
    {
    public:
        virtual Status addBlock(const SetOfKeyValuePairs& updates, BlockId& outBlockId) = 0;
    };

    class ILocalKeyValueStorageReadOnly
    {
    public:
        virtual BlockId getLastBlock() const = 0;

        // get SetOfKeyValuePairs of block blockId
        virtual Status getBlockData(BlockId blockId, SetOfKeyValuePairs& outBlockData) const = 0;

        // get value of a key (returns the latest version of the key)
        virtual Status get(Key key, Value& outValue) const = 0;

        // get value of a key (returns the latest version before readVersion+1)
        virtual Status get(BlockId readVersion, Slice key, Slice& outValue, BlockId& outBlock) const = 0;

        // returns outRes==true if key has been changed between block fromBlock and toBlock.
        virtual Status mayHaveConflictBetween(Slice key, BlockId fromBlock, BlockId toBlock, bool& outRes) const = 0;

        virtual ILocalKeyValueStorageReadOnlyIterator* getSnapIterator() const = 0;
        virtual Status freeSnapIterator(ILocalKeyValueStorageReadOnlyIterator* iter) const = 0;
    };

    class ILocalKeyValueStorageReadOnlyIterator
    {
    public:
        virtual KeyValuePair getCurrent() = 0; // Return current element without moving
        virtual bool         isEnd() = 0;          // Check if iterator is in the end.

        // simple iteration (on the latest version of keys)
        virtual KeyValuePair first() = 0;
        virtual KeyValuePair seekAtLeast(Key key) = 0;
        virtual KeyValuePair next() = 0;

        // iteration on a specific read version
        virtual KeyValuePair first(BlockId readVersion, BlockId& actualVersion, bool& isEnd) = 0;
        virtual KeyValuePair seekAtLeast(BlockId readVersion, Key key, BlockId& actualVersion, bool& isEnd) = 0; // Assumes lexicographical ordering of the keys, seek the first element k >= key
        virtual KeyValuePair next(BlockId readVersion, Key key, BlockId& actualVersion, bool& isEnd) = 0; // Proceed to next element and return it
    };
}