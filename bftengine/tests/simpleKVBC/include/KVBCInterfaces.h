// Concord
//
// Copyright (c) 2018 VMware, Inc. All Rights Reserved.
//
// This product is licensed to you under the Apache 2.0 license (the "License").
// You may not use this product except in compliance with the Apache 2.0
// License.
//
// This product may include a number of subcomponents with separate copyright
// notices and license terms. Your use of these subcomponents is subject to the
// terms and conditions of the subcomponent's license, as noted in the LICENSE
// file.

#pragma once

#include <string>
#include <iterator>
#include "Status.h"
#include "ICommunication.hpp"
#include "PrimitiveTypes.h"
#include "SetOfKeyValuePairs.h"

namespace SimpleKVBC {

// forward declarations
class ILocalKeyValueStorageReadOnlyIterator;
class ILocalKeyValueStorageReadOnly;
class IBlocksAppender;
class ICommandsHandler;

/////////////////////////////////////////////////////////////////////////////
// Configuration
/////////////////////////////////////////////////////////////////////////////

struct ReplicaConfig {
  // F value - max number of faulty/malicious replicas. fVal >= 1
  uint16_t fVal;

  // C value. cVal >=0
  uint16_t cVal;

  // unique identifier of the replica.
  // The number of replicas in the system should be N = 3*fVal + 2*cVal + 1
  // In the current version, replicaId should be a number between 0 and  N-1
  // replicaId should also represent this replica in ICommunication.
  uint16_t replicaId;

  // path of the replica's security keys file (generated by
  // CONCORD-ROOT/tools/GenerateConcordKeys)
  std::string pathOfKeysfile;

  // number of objects that represent clients.
  // numOfClientProxies >= 1
  uint16_t numOfClientProxies;

  // a time interval in milliseconds. represents how often the replica sends a
  // status report to the other replicas. statusReportTimerMillisec > 0
  uint16_t statusReportTimerMillisec;

  // number of consensus operations that can be executed in parallel
  // 1 <= concurrencyLevel <= 30
  uint16_t concurrencyLevel;

  // autoViewChangeEnabled=true , if the automatic view change protocol is
  // enabled
  bool autoViewChangeEnabled;

  // a time interval in milliseconds. represents the timeout used by the  view
  // change protocol (TODO: add more details)
  uint16_t viewChangeTimerMillisec;

  // maximum block size
  uint32_t maxBlockSize;
};

struct ClientConfig {
  // F value - max number of faulty/malicious replicas. fVal >= 1
  uint16_t fVal;

  // C value. cVal >=0
  uint16_t cVal;

  // unique identifier of the client.
  // clientId should also represent this client in ICommunication.
  // In the current version, replicaId should be a number between N and
  // N+numOfClientProxies-1 (N is the number replicas in the system.
  // numOfClientProxies is part of the replicas' configuration)
  uint16_t clientId;

  // maximum reply size supported by this client
  uint32_t maxReplySize;
};

/////////////////////////////////////////////////////////////////////////////
// Client proxy
/////////////////////////////////////////////////////////////////////////////

// Represents a client of the blockchain database
class IClient {
 public:
  virtual Status start() = 0;
  virtual Status stop() = 0;

  virtual bool isRunning() = 0;

  virtual Status invokeCommandSynch(const Slice command,
                                    bool isReadOnly,
                                    Slice& outReply) = 0;

  virtual Status release(
      Slice& slice) = 0;  // release memory allocated by invokeCommandSynch
};

// creates a new Client object
IClient* createClient(const ClientConfig& conf,
                      bftEngine::ICommunication* comm);

// TODO: Implement:
//  // deletes a Client object
//  void release(IClient* r);

/////////////////////////////////////////////////////////////////////////////
// Replica
/////////////////////////////////////////////////////////////////////////////

// Represents a replica of the blockchain database
class IReplica {
 public:
  virtual Status start() = 0;
  virtual Status stop() = 0;

  enum class RepStatus  // status of the replica
  { UnknownError = -1,
    Ready = 0,
    Starting,
    Running,
    Stopping,
  };

  // returns the current status of the replica
  virtual RepStatus getReplicaStatus() const = 0;

  // TODO: Implement:
  //      // this callback is called by the library every time the replica
  //      status is changed typedef void(*StatusNotifier)(RepStatus newStatus);
  //      virtual Status setStatusNotifier(StatusNotifier statusNotifier);
  //
  //      // Used to update the local storage (may be needed for initializing
  //      and maintenance).
  //      // Can only be used when the replica's status is Idle.
  //      virtual const ILocalKeyValueStorageReadOnly& getReadOnlyStorage() = 0;
  //      virtual Status addBlockToIdleReplica(const SetOfKeyValuePairs&
  //      updates) = 0; // write the updates by adding a block
};

// creates a new Replica object
IReplica* createReplica(const ReplicaConfig& conf,
                        bftEngine::ICommunication* comm,
                        ICommandsHandler* _cmdHandler);

// TODO: Implement:
//  // deletes a Replica object
//  void release(IReplica* r);

/////////////////////////////////////////////////////////////////////////////
// Replica's commands handle
/////////////////////////////////////////////////////////////////////////////

class ICommandsHandler {
 public:
  virtual bool executeCommand(const Slice command,
                              const ILocalKeyValueStorageReadOnly& roStorage,
                              IBlocksAppender& blockAppender,
                              const size_t maxReplySize,
                              char* outReply,
                              size_t& outReplySize) const = 0;

  virtual bool executeReadOnlyCommand(
      const Slice command,
      const ILocalKeyValueStorageReadOnly& roStorage,
      const size_t maxReplySize,
      char* outReply,
      size_t& outReplySize) const = 0;
};

// Blocks appender
class IBlocksAppender {
 public:
  virtual Status addBlock(const SetOfKeyValuePairs& updates,
                          BlockId& outBlockId) = 0;
};

class ILocalKeyValueStorageReadOnly {
 public:
  virtual BlockId getLastBlock() const = 0;

  // get SetOfKeyValuePairs of block blockId
  virtual Status getBlockData(BlockId blockId,
                              SetOfKeyValuePairs& outBlockData) const = 0;

  // get value of a key (returns the latest version of the key)
  virtual Status get(Key key, Value& outValue) const = 0;

  // get value of a key (returns the latest version before readVersion+1)
  virtual Status get(BlockId readVersion,
                     Slice key,
                     Slice& outValue,
                     BlockId& outBlock) const = 0;

  // returns outRes==true if key has been changed between block fromBlock and
  // toBlock.
  virtual Status mayHaveConflictBetween(Slice key,
                                        BlockId fromBlock,
                                        BlockId toBlock,
                                        bool& outRes) const = 0;

  virtual ILocalKeyValueStorageReadOnlyIterator* getSnapIterator() const = 0;
  virtual Status freeSnapIterator(
      ILocalKeyValueStorageReadOnlyIterator* iter) const = 0;
};

class ILocalKeyValueStorageReadOnlyIterator {
 public:
  virtual KeyValuePair
  getCurrent() = 0;          // Return current element without moving
  virtual bool isEnd() = 0;  // Check if iterator is in the end.

  // simple iteration (on the latest version of keys)
  virtual KeyValuePair first() = 0;
  virtual KeyValuePair seekAtLeast(Key key) = 0;
  virtual KeyValuePair next() = 0;

  // iteration on a specific read version
  virtual KeyValuePair first(BlockId readVersion,
                             BlockId& actualVersion,
                             bool& isEnd) = 0;
  virtual KeyValuePair seekAtLeast(
      BlockId readVersion,
      Key key,
      BlockId& actualVersion,
      bool& isEnd) = 0;  // Assumes lexicographical ordering of the keys, seek
                         // the first element k >= key
  virtual KeyValuePair next(
      BlockId readVersion,
      Key key,
      BlockId& actualVersion,
      bool& isEnd) = 0;  // Proceed to next element and return it
};
}  // namespace SimpleKVBC