// Copyright 2021 VMware, all rights reserved
//
// Concord Client's State Snapshot Service

syntax = "proto3";
package vmware.concord.client.statesnapshot.v1;

import "google/protobuf/empty.proto";
import "google/protobuf/wrappers.proto";

option java_package = "com.vmware.concord.client.statesnapshot.v1";

// The StateSnapshot service can be used to initialize a Client Application from a
// state snapshot visible to Concord Client. State snapshots aggregate all writes
// to the `STORAGE_SPACE_MERKLE` storage space from the start of the blockchain up
// to a specific point that is determined by the event group ID as of which the
// state snapshot is generated.
//
// State contains only the last write to a key-value in the `STORAGE_SPACE_MERKLE`
// storage space and no prior historical writes. We use `state`, `state snapshot`,
// `snapshot` and `STORAGE_SPACE_MERKLE` to refer to all key-values that are part
// of a snapshot from now on.
//
// To visualize, we show how events are streamed from Concord Client to the
// Client Application (App) and the relation between state and event group IDs:
// ----------------------------------------------------------------------------
//                               [State Snapshot at evgN]
//                                          |
//                                          v
// ------------------                                            --------------
// | Concord Client |  -- evg1, evg2, ..., evgN, evgN+1, ... ->  | Client App |
// ------------------                                            --------------
// ----------------------------------------------------------------------------
// where `evgN` is the Nth event group streamed from Concord Client to the Client App.
// After receiving a state snapshot at `evgN`, a Client App can continue operation by
// consuming event groups from `evgN+1` onwards.
//
// Concord Client ensures that there is always at least one reasonably
// recent snapshot that can be served. The intention is that this snapshot is
// used to initialize the Client Application after the network has been pruned and
// some set of historical events are no longer available via the `EventService`.
//
// See `event.proto` for more information about events, event group IDs and
// `EventService`.
// See `execution_engine.proto` for more information about storage spaces.
//
// Note: The StateSnapshot service only supports snapshots based on event group IDs
// and not legacy events that are based on block IDs.
service StateSnapshot {
  // Get the event group ID at which there is a recent and available snapshot.
  // Errors:
  // UNAVAILABLE: if Concord Client is not ready yet to process requests.
  // UNKNOWN: exact cause is unknown.
  rpc GetRecentSnapshot(GetRecentSnapshotRequest) returns (GetRecentSnapshotResponse);

  // Stream a specific state snapshot in a resumable fashion as a finite stream of key-values.
  // Key-values are streamed with lexicographic order on keys.
  // Errors:
  // NOT_FOUND: if the snapshot at the requested event group ID is not (or no longer) available.
  //            Client applications are advised to retry initialization by
  //            fetching a new event group ID.
  // INVALID_ARGUMENT: if resuming a stream using `from_key` and that key is
  //                   not part of the snapshot.
  // UNAVAILABLE: if Concord Client is not ready yet to process requests.
  // UNKNOWN: exact cause is unknown.
  rpc StreamSnapshot(StreamSnapshotRequest) returns (stream StreamSnapshotResponse);

  // Read the values of given keys as of a specific snapshot.
  // Errors:
  // NOT_FOUND: if the snapshot at the requested event group ID is not (or no longer) available.
  //            Client applications are advised to retry initialization by
  //            fetching a new event group ID.
  // UNAVAILABLE: if Concord Client is not ready yet to process requests.
  // UNKNOWN: exact cause is unknown.
  rpc ReadAsOf(ReadAsOfRequest) returns (ReadAsOfResponse);
}

message GetRecentSnapshotRequest {
}

message GetRecentSnapshotResponse {
  // Mandatory field.
  //
  // The event group ID at which there is a recent and available snapshot.
  uint64 event_group_id = 1;

  // Mandatory field.
  //
  // An estimate (with reasonable accuracy) of the count of key-values
  // contained in the snapshot. Please note that this is an estimation
  // and *not* the actual count.
  uint64 key_value_count_estimate = 2;
}

message StreamSnapshotRequest {  
  // Mandatory field.
  //
  // The event group ID at which to stream state.
  uint64 event_group_id = 1;

  // Optional field.
  //
  // If set, start streaming `from_key` onwards. If `from_key` is not part
  // of the snapshot, an INVALID_ARGUMENT error is returned.
  //
  // If not set, start streaming from the first key-value in the snapshot.
  //
  // The empty bytestring is a valid key.
  //
  // Key-values are streamed with lexicographic order on keys.
  google.protobuf.BytesValue from_key = 2;
}

message KeyValuePair {
  // Mandatory field.
  //
  // The key.
  bytes key = 1;

  // Mandatory field.
  //
  // The value.
  bytes value = 2;
}

message StreamSnapshotResponse {
  // Mandatory field.
  KeyValuePair key_value = 1;
}

message ReadAsOfRequest {
  // Event group ID as of which to read the values.
  uint64 event_group_id = 1;

  // List of keys for which the values should be returned.
  repeated bytes keys = 2;
}

message OptionalValue {
  oneof option {
    google.protobuf.Empty non_existent = 1;
    bytes value = 2;
  }
}

message ReadAsOfResponse {
  // The `values` list contains entries for all requested keys
  // in `ReadAsOfRequest.keys`, i.e. it is the exact same length.
  //
  // If a key-value has been deleted or has never been set,
  // `OptionalValue.option.non_existent` will be set. Otherwise,
  // `OptionalValue.option.value` will be set with the value as
  // of the requested snapshot.
  repeated OptionalValue values = 1;
}
