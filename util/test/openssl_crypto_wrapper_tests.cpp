// Concord
//
// Copyright (c) 2021 VMware, Inc. All Rights Reserved.
//
// This product is licensed to you under the Apache 2.0 license (the "License").
// You may not use this product except in compliance with the Apache 2.0
// License.
//
// This product may include a number of subcomponents with separate copyright
// notices and license terms. Your use of these subcomponents is subject to the
// terms and conditions of the subcomponent's license, as noted in the
// LICENSE file.

#include "gtest/gtest.h"

#include "openssl_crypto_utils.hpp"

using concord::util::openssl_crypto::AsymmetricPrivateKey;
using concord::util::openssl_crypto::AsymmetricPublicKey;
using concord::util::openssl_crypto::deserializePrivateKey;
using concord::util::openssl_crypto::deserializePrivateKeyFromPemString;
using concord::util::openssl_crypto::deserializePublicKey;
using concord::util::openssl_crypto::generateAsymmetricCryptoKeyPair;
using concord::util::openssl_crypto::kPermittedAsymmetricCryptoSchemes;
using std::invalid_argument;
using std::pair;
using std::string;
using std::unique_ptr;
using std::vector;

namespace {

// Note some of these test cases assume that each key pair generated by
// generateAsymmetricCryptoKeyPair will be unique. While the pseudorandom key
// generation process may not actually guarantee this will always be the case,
// the probably of a random key collision should be so low that they will not
// cause noticibale flakiness in this unit testing (and if such collisions are
// noticably frequent, we should scrutinize whether the pseudorandom key
// generation is in fact of cryptographic quality).

const size_t kNumKeyPairsToTryPerCase = 4;
const vector<string> kMessagesToTry({"A",
                                     "message",
                                     "This message is not random or pseudorandom.",
                                     "",
                                     "The following message will contian information taken from ",
                                     "https://www.random.org.",
                                     "jSm13lpKQsSYY3o5 QvC2gGLAMVpuLDMO 5S82pwgh2aIeBXqX M4b7RvvRnFhWSDtq ",
                                     "YaF6EIpFZHcrgIgt h4vrEh00JKLTPhQi Ouj46nhAkmGgoa26 y1UKWRKM4T22ZygV ",
                                     "0Ev33yxXLMw2OF5M 6nnvYvtNOuiZgbQ3 cgPzgsyw2jBZGzUh juU97uAzB6qFQbK4 ",
                                     "MFMm3OuW48o0TUbA 5IqzqXYx7H8X1V9v 6OrU65OGVNKnhbuF IargH10iAtVoGYML ",
                                     "zegQbjZZYNl2Jpzt HmNO0Dn18lj7rQPc Jxo1ovjAeGChx2n6 o4QNKPe7aM5MPtae ",
                                     "1J8ZF7S39gAuqNBP 2Rm1vjOKEcNSwp9O aBTVOHdp2tKGmwer rZ14IZU6ZH7Wo7dB ",
                                     "UyZLiXiYJJzqmTbE rxWEr6WEttciAv0Y OZ11VwrFwbNmybSX 661lsE8ScAkjaxha ",
                                     "mtrT0tYEZM93Qm6y LieAqDd047q62pog v9f3buXgWCq8eyuY w3FTB51Jl3GGW9qt ",
                                     "f5Ndarhg2USDQozO Nyy9OOXn54nc7Rwf zUmj4Zhy6cRkVIk1 WnfxOzJV0vVWhjsC ",
                                     "GE6FoDXkXa83B9gk FE58tyErNNXLuMOd Qt8JmPFT70DzPTkB diiqF0n6k4UoYIfS ",
                                     "Nr2no9OU6ZalESHw QOgqolYmaVuvHD3w el9fMRoAthO5ZJau xjZZATDgLCKd3CKx ",
                                     "CHUEffypTqpRaH31 skZV5jKkwy6AwfkO JhIxs7eoqkKQED4P Ux3pQEOqDiTMsFdw"});

TEST(openssl_crypto_wrapper_test, asymmetric_key_generation) {
  // Key generation should fail for an invalid cryptographic scheme.
  EXPECT_THROW(generateAsymmetricCryptoKeyPair("This string shouldn't match any permitted cryptographic scheme."),
               invalid_argument)
      << "generateAsymmetricCryptoKeyPair returned without throwing an "
         "exception when called with a string that shouldn't match a permitted "
         "cryptographic scheme.";

  // There should be a positive number of permitted asymmetric cryptography
  // schemes.
  EXPECT_GT(kPermittedAsymmetricCryptoSchemes.size(), 0)
      << "The OpenSSL Crypto Utilities apparently do not actually permit using "
         "any asymmetric cryptography schemes.";

  // Key generation should not fail for any permitted key type.
  for (const string& scheme : kPermittedAsymmetricCryptoSchemes) {
    pair<unique_ptr<AsymmetricPrivateKey>, unique_ptr<AsymmetricPublicKey>> key_pair =
        generateAsymmetricCryptoKeyPair(scheme);
    EXPECT_NE(key_pair.first, nullptr) << "generateAsymmetricCryptoKeyPair returned a null pointer for the "
                                          "private key for the allegedly permitted "
                                       << scheme << " crypto scheme.";
    EXPECT_NE(key_pair.second, nullptr) << "generateAsymmetricCryptoKeyPair returned a null pointer for the "
                                           "public key for the allegedly permitted "
                                        << scheme << " crypto scheme.";
  }
}

TEST(openssl_crypto_wrapper_test, asymmetric_key_compatibility) {
  // A signature made with a private key should be verifiable with the
  // corresponding public key.
  for (const string& scheme : kPermittedAsymmetricCryptoSchemes) {
    for (size_t i = 0; i < kNumKeyPairsToTryPerCase; ++i) {
      pair<unique_ptr<AsymmetricPrivateKey>, unique_ptr<AsymmetricPublicKey>> key_pair =
          generateAsymmetricCryptoKeyPair(scheme);
      for (const string& message : kMessagesToTry) {
        EXPECT_TRUE(key_pair.second->verify(message, key_pair.first->sign(message)))
            << "Under the " << scheme
            << " crypto scheme, an AsymmetricPublicKey failed to validate a "
               "signature produced with the corresponding "
               "AsymmetricPrivateKey.";
      }
    }
  }
}

TEST(openssl_crypto_wrapper_test, asymmetric_key_serialization) {
  // Deserializing serialized keys should return keys equivalent to those that
  // were originally serialized.
  for (const string& scheme : kPermittedAsymmetricCryptoSchemes) {
    for (size_t i = 0; i < kNumKeyPairsToTryPerCase; ++i) {
      pair<unique_ptr<AsymmetricPrivateKey>, unique_ptr<AsymmetricPublicKey>> key_pair =
          generateAsymmetricCryptoKeyPair(scheme);
      pair<unique_ptr<AsymmetricPrivateKey>, unique_ptr<AsymmetricPublicKey>> serialized_key_pair = make_pair(
          deserializePrivateKey(key_pair.first->serialize()), deserializePublicKey(key_pair.second->serialize()));
      for (const string& message : kMessagesToTry) {
        EXPECT_TRUE(key_pair.second->verify(message, serialized_key_pair.first->sign(message)))
            << "Under the " << scheme
            << " crypto scheme, an AsymmetricPublicKey failed to validate a "
               "signature made with an AsymmetricPrivateKey deserialized from "
               "the serialization of the private key that originally matched "
               "that public key.";
        EXPECT_TRUE(serialized_key_pair.second->verify(message, key_pair.first->sign(message)))
            << "Under the " << scheme
            << " crypto scheme, an AsymmetricPublicKey created by "
               "deserializing a serialized AsymmetricPublicKey failed to "
               "validate a signature made with the private key matching the "
               "original public key object.";
      }
    }
  }

  // Attempting to deserialize from strings not containing well-formed
  // serialized keys should yield an exception.
  EXPECT_THROW(deserializePrivateKey(""), invalid_argument)
      << "Attempting to deserialize an AsymmetricPrivateKey from an empty "
         "string did not yield an exception.";
  EXPECT_THROW(deserializePublicKey(""), invalid_argument)
      << "Attempting to deserialize an AsymmetricPublicKey from an empty "
         "string did not yield an exception.";
  EXPECT_THROW(deserializePrivateKey("This string probably should not be "
                                     "interpretable as a private key for "
                                     "an asymmetric cryptography scheme."),
               invalid_argument)
      << "Attempting to deserialize an AsymmetricPrivateKey from a string that "
         "probably should not be interpretable as a private key did not yeild "
         "an exception.";
  EXPECT_THROW(deserializePublicKey("This string probably should not be "
                                    "interpreetable as a public key for "
                                    "an asymmetric cryptography scheme."),
               invalid_argument)
      << "Attempting to deserialize an AsymmetricPublicKey from a string that "
         "probably should not be interpretable as a public key did not yeild "
         "an exception.";
}

TEST(openssl_crypto_wrapper_test, asymmetric_key_signature_verification) {
  // A public key should fail to verify signatures produced with non-matching
  // public keys.
  for (const string& scheme : kPermittedAsymmetricCryptoSchemes) {
    vector<pair<unique_ptr<AsymmetricPrivateKey>, unique_ptr<AsymmetricPublicKey>>> key_pairs;
    for (size_t i = 0; i < kNumKeyPairsToTryPerCase; ++i) {
      key_pairs.push_back(generateAsymmetricCryptoKeyPair(scheme));
    }
    for (size_t i = 0; i < kNumKeyPairsToTryPerCase; ++i) {
      for (size_t j = 0; j < kNumKeyPairsToTryPerCase; ++j) {
        if (i != j) {
          for (const string& message : kMessagesToTry) {
            EXPECT_FALSE(key_pairs[j].second->verify(message, key_pairs[i].first->sign(message)))
                << "Under the " << scheme
                << " crypto scheme, an AsymmetricPublicKey found a signature "
                   "produced with a non-matching AsymmetricPrivateKey to be "
                   "valid.";
          }
        }
      }
    }
  }

  // A public key should fail to verify a signature produced with the
  // corresponding private key when the message to be verified does not match
  // the message that was signed.
  for (const string& scheme : kPermittedAsymmetricCryptoSchemes) {
    for (size_t i = 0; i < kNumKeyPairsToTryPerCase; ++i) {
      pair<unique_ptr<AsymmetricPrivateKey>, unique_ptr<AsymmetricPublicKey>> key_pair =
          generateAsymmetricCryptoKeyPair(scheme);
      for (const string& message : kMessagesToTry) {
        for (const string& different_message : kMessagesToTry) {
          if (message != different_message) {
            EXPECT_FALSE(key_pair.second->verify(different_message, key_pair.first->sign(message)))
                << "Under the " << scheme
                << " crypto scheme, an AsymmetricPublicKey found a signature "
                   "signed by a matching AsymmetricPrivateKey to be valid for "
                   "a different message than the one that was signed.";
          }
        }
      }
    }
  }

  // A public key should fail to verify a signature if it is given a malformed
  // signature.
  for (const string& scheme : kPermittedAsymmetricCryptoSchemes) {
    for (size_t i = 0; i < kNumKeyPairsToTryPerCase; ++i) {
      pair<unique_ptr<AsymmetricPrivateKey>, unique_ptr<AsymmetricPublicKey>> key_pair =
          generateAsymmetricCryptoKeyPair(scheme);
      for (const string& message : kMessagesToTry) {
        EXPECT_FALSE(key_pair.second->verify(message, ""))
            << "Under the " << scheme
            << " crypto scheme, an AsymmetricPublicKey found an empty string "
               "to be a valid signature for a message.";
        EXPECT_FALSE(key_pair.second->verify(message, "This should not be a valid signature."))
            << "Under the " << scheme
            << " crypto scheme, an AsymmetricPublicKey found a string that "
               "should not be a valid signature to be a valid signature for a "
               "message.";
      }
    }
  }
}

TEST(openssl_crypto_wrapper_test, read_ec_private_key_from_string) {
  const std::string key_as_str{
      R"KEEY(
-----BEGIN EC PRIVATE KEY-----
MHcCAQEEIEWf8ZTkCWbdA9WrMSNGCC7GQxvSXiDlU6dlZAi6JaCboAoGCCqGSM49
AwEHoUQDQgAENEMHcbJgnnYxfa1zDlIF7lzp/IoaNfwGuJpAg84an5FdPALwZwBp
/m/X3d8kwmfZEytqt2PGMNhHMkovIaRI1A==
-----END EC PRIVATE KEY-----)KEEY"};

  auto p = deserializePrivateKeyFromPemString(key_as_str, "secp256r1");
  EXPECT_TRUE(p);
}
}  // anonymous namespace

int main(int argc, char** argv) {
  ::testing::InitGoogleTest(&argc, argv);

  return RUN_ALL_TESTS();
}
